堆内存从GC角度分为新生代和老年代，其中新生代又分为Eden区、Survivor1和Survivor2。

新生代：用来存放新生的对象，由于频繁创建对象，会频繁触发MinorGC进行垃圾回收

​	Eden区：Java新对象出生地，

​	ServivorFrom：上一次 GC 的幸存者，作为这一次 GC 的被扫描者

​	ServivorTo：保留了一次 MinorGC 过程中的幸存者

新生代因为每次GC会有大批量对象被回收，所以MinorGC采用复制算法。

​	复制算法：将内存分为大小相同的两块，每次只使用一块，这块内存存满之后将还存活的对象复制到另一块上，把当前内存清空。缺点是可用内存被压缩到原本的一半。

老年代：主要存放生命周期长的对象，比较稳定，MajorGC不会频繁执行，有新生代对象进入老年代，导致空间不够时才会触发，MajorGC采用标记清除算法。

​	标记清除算法：两个阶段，标注和清除。标记阶段标记处所有需要回收的对象，清除阶段回收被标记的对象所占用的空间，缺点在于内存碎片化严重，会发生大对象找不到可用内存。





串行GC：

  Serial 单线程， 使用复制算法。进行垃圾回收同时暂停其他所有工作线程，简单高效。

  ParNew 多线程，复制算法。

  Parallel Scavenge 复制算法多线程。

CMS 多线程 标记清除算法。老年代垃圾收集器，主要目标是获取最短垃圾回收停顿时间。

G1 GC 标记整理算法。可用精确控制停顿时间，不牺牲吞吐量前提下，实现低停顿垃圾回收。